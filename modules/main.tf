# S3 Bucket Provisioning — Generated by PrismFlow

locals {
  buckets_map = { for b in var.buckets : b.name => b }
}

# ── Buckets ───────────────────────────────────────────────────────────

resource "aws_s3_bucket" "buckets" {
  for_each = local.buckets_map

  bucket              = "${var.project_name}-${each.value.name}"
  object_lock_enabled = each.value.object_lock_enabled

  tags = merge(each.value.tags, {
    Tier        = each.value.tier
    ManagedBy   = "PrismFlow"
    Environment = var.environment
  })
}

# ── Versioning ────────────────────────────────────────────────────────

resource "aws_s3_bucket_versioning" "buckets" {
  for_each = { for k, b in local.buckets_map : k => b if b.versioning }

  bucket = aws_s3_bucket.buckets[each.key].id

  versioning_configuration {
    status     = "Enabled"
    mfa_delete = each.value.mfa_delete ? "Enabled" : "Disabled"
  }
}

# ── Encryption ────────────────────────────────────────────────────────

resource "aws_s3_bucket_server_side_encryption_configuration" "buckets" {
  for_each = { for k, b in local.buckets_map : k => b if b.encryption != "none" }

  bucket = aws_s3_bucket.buckets[each.key].id

  rule {
    bucket_key_enabled = each.value.encryption == "aws:kms" ? each.value.bucket_key_enabled : null

    apply_server_side_encryption_by_default {
      sse_algorithm     = each.value.encryption
      kms_master_key_id = each.value.encryption == "aws:kms" && each.value.kms_key_arn != "" ? each.value.kms_key_arn : null
    }
  }
}

# ── Public Access Block ───────────────────────────────────────────────

resource "aws_s3_bucket_public_access_block" "buckets" {
  for_each = { for k, b in local.buckets_map : k => b if b.block_public_access }

  bucket = aws_s3_bucket.buckets[each.key].id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

# ── Lifecycle Configuration ───────────────────────────────────────────

resource "aws_s3_bucket_lifecycle_configuration" "buckets" {
  for_each = { for k, b in local.buckets_map : k => b if length(b.lifecycle_rules) > 0 || b.intelligent_tiering || b.abort_incomplete_multipart_days > 0 || b.noncurrent_version_expiration_days > 0 }

  bucket = aws_s3_bucket.buckets[each.key].id

  dynamic "rule" {
    for_each = each.value.intelligent_tiering ? [1] : []

    content {
      id     = "intelligent-tiering"
      status = "Enabled"

      transition {
        storage_class = "INTELLIGENT_TIERING"
      }
    }
  }

  dynamic "rule" {
    for_each = each.value.abort_incomplete_multipart_days > 0 ? [1] : []

    content {
      id     = "abort-incomplete-multipart"
      status = "Enabled"

      abort_incomplete_multipart_upload {
        days_after_initiation = each.value.abort_incomplete_multipart_days
      }
    }
  }

  dynamic "rule" {
    for_each = each.value.noncurrent_version_expiration_days > 0 ? [1] : []

    content {
      id     = "noncurrent-version-expiration"
      status = "Enabled"

      noncurrent_version_expiration {
        noncurrent_days = each.value.noncurrent_version_expiration_days
      }
    }
  }

  dynamic "rule" {
    for_each = contains(each.value.lifecycle_rules, "glacier-30") ? [1] : []

    content {
      id     = "glacier-30"
      status = "Enabled"

      transition {
        days          = 30
        storage_class = "GLACIER"
      }
    }
  }

  dynamic "rule" {
    for_each = contains(each.value.lifecycle_rules, "glacier-90") ? [1] : []

    content {
      id     = "glacier-90"
      status = "Enabled"

      transition {
        days          = 90
        storage_class = "GLACIER"
      }
    }
  }

  dynamic "rule" {
    for_each = contains(each.value.lifecycle_rules, "deep-archive-180") ? [1] : []

    content {
      id     = "deep-archive-180"
      status = "Enabled"

      transition {
        days          = 180
        storage_class = "DEEP_ARCHIVE"
      }
    }
  }

  dynamic "rule" {
    for_each = contains(each.value.lifecycle_rules, "delete-365") ? [1] : []

    content {
      id     = "delete-365"
      status = "Enabled"

      expiration {
        days = 365
      }
    }
  }
}

# ── Access Logging ────────────────────────────────────────────────────

resource "aws_s3_bucket_logging" "buckets" {
  for_each = { for k, b in local.buckets_map : k => b if b.access_logging && b.log_target_bucket != "" }

  bucket = aws_s3_bucket.buckets[each.key].id

  target_bucket = each.value.log_target_bucket
  target_prefix = each.value.log_prefix
}

# ── Transfer Acceleration ─────────────────────────────────────────────

resource "aws_s3_bucket_accelerate_configuration" "buckets" {
  for_each = { for k, b in local.buckets_map : k => b if b.transfer_acceleration }

  bucket = aws_s3_bucket.buckets[each.key].id
  status = "Enabled"
}

# ── Object Lock ───────────────────────────────────────────────────────

resource "aws_s3_bucket_object_lock_configuration" "buckets" {
  for_each = { for k, b in local.buckets_map : k => b if b.object_lock_enabled && b.object_lock_mode != "" }

  bucket = aws_s3_bucket.buckets[each.key].id

  rule {
    default_retention {
      mode = each.value.object_lock_mode
      days = each.value.object_lock_retention_days
    }
  }
}

# ── SSL Enforcement Policy ────────────────────────────────────────────

resource "aws_s3_bucket_policy" "enforce_ssl" {
  for_each = { for k, b in local.buckets_map : k => b if b.enforce_ssl }

  bucket = aws_s3_bucket.buckets[each.key].id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid       = "EnforceSSLOnly"
        Effect    = "Deny"
        Principal = "*"
        Action    = "s3:*"
        Resource = [
          aws_s3_bucket.buckets[each.key].arn,
          "${aws_s3_bucket.buckets[each.key].arn}/*"
        ]
        Condition = {
          Bool = {
            "aws:SecureTransport" = "false"
          }
        }
      }
    ]
  })
}

# ── Cross-Region Replication ──────────────────────────────────────────

resource "aws_iam_role" "replication" {
  count = length([for b in var.buckets : b if b.replication_enabled]) > 0 ? 1 : 0
  name  = "${var.project_name}-s3-replication-${var.environment}"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = {
        Service = "s3.amazonaws.com"
      }
    }]
  })
}

resource "aws_s3_bucket_replication_configuration" "buckets" {
  for_each = { for k, b in local.buckets_map : k => b if b.replication_enabled && b.replication_destination_bucket != "" }

  depends_on = [aws_s3_bucket_versioning.buckets]

  role   = aws_iam_role.replication[0].arn
  bucket = aws_s3_bucket.buckets[each.key].id

  rule {
    id     = "replicate-all"
    status = "Enabled"

    destination {
      bucket        = "arn:aws:s3:::${each.value.replication_destination_bucket}"
      storage_class = "STANDARD"
    }
  }
}
